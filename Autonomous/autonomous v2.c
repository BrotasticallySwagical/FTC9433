#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     liftLeftBottom, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     liftLeftTop,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftRightTop,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     liftRightBottom, tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    latchRight,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    latchLeft,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    intakeLeft,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_4,    intakeRight,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
 
/* Janurary 8th, 2014
Chris: ZOMG they kept pushing back the finish-build time so I had no time to tune/work on the other
autonomous. I just made this so we could get some points by getting off the ramp and parking the 60cm
rolling goal. Eh it's alright. Really dependent and stuff, so it's not close to being accurate...
 
*/
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
 
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define BOUND(num, low, high) (num < low) ? low : ((num > high) ? high : num)   //We don't want to set the motors higher than -100 or 100, so limit it!
const float ENCODER_TICKS_PER_INCH = 152.788745368;
const int perfect90 = 1980; // [16.5 inches * pi (circle that a point turn makes) / 4 (90 degrees is 360 degrees divided by 4)] * ENCODER_TICKS_PER_INCH
 
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
 
void initializeRobot()
{
    // Place code here to sinitialize servos to starting positions.
    // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
 
    servo[latchLeft] = 255;
    servo[latchRight] = 0;
    servo[intakeLeft] = 127;
    servo[intakeRight] = 127;
 
    /*  motor[liftLeftTop] = -30;
    motor[liftLeftBottom] = -60;
    motor[liftRightTop] = -30;
    motor[liftRightBottom] = -60;
    wait1Msec(250);
    motor[liftLeftTop] = 0;
    motor[liftLeftBottom] = 0;
    motor[liftRightTop] = 0;
    motor[liftRightBottom] = 0;*/
    return;
}
 
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int lSpeed = 0, rSpeed = 0;
int lError = 0, rError = 0, error = 0;
int kp = 2;
bool get90Cm = false;
int platformStart = 5;  //If we start on the top of the platform, then add 5in when getting to the rolling goal
int waitTimes[] = {0, 0};   //Wait times so we can adapt to other teams' autonomous
 
void moveStraight(int distInInches)
{
    int encoderDist = distInInches * ENCODER_TICKS_PER_INCH;
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
    while(abs(nMotorEncoder[liftLeftTop]) < abs(encoderDist) && abs(nMotorEncoder[liftRightBottom]) < abs(encoderDist))
    {
        if(nMotorEncoder[liftLeftTop] != nMotorEncoder[liftRightBottom])
        {
            error   = nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];
        }
        lError = encoderDist - nMotorEncoder[liftLeftTop];
        rError = encoderDist - nMotorEncoder[liftRightBottom] + error;
 
        lSpeed = BOUND(lError / kp, -100, 100);
        rSpeed = BOUND(rError / kp, -100, 100);
        motor[frontLeft] = lSpeed;
        motor[frontRight] = rSpeed;
        motor[backLeft] = lSpeed;
        motor[backRight] = rSpeed;
    }
}
 
void selectStart()
{
    nxtDisplayString(0, "Platform Position?");
    while(nNxtButtonPressed != 3)
    {
        if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2)
        {
            if(platformStart == 0) platformStart = 5;
            else platformStart = 0;
            if(platformStart == 0) nxtDisplayString(1, "!Top");
            else nxtDisplayString(1, "!Bottom");
            wait1Msec(250);
        }
        wait1Msec(250);
    }
    nxtDisplayString(1, ">"); //Change from "!Platform" to ">Platform"
 
    wait1Msec(500);
 
    nxtDisplayString(3, "Get 90cm?")
    while(nNxtButtonPressed != 3)
    {
        if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2)
        {
            get90Cm = !get90Cm;
            if(get90Cm == true) nxtDisplayString(4, "!Yes");
            else nxtDisplayString(1, "!No");
            wait1Msec(250);
        }
        wait1Msec(250);
    }
    nxtDisplayString(4, ">");
}
 
void selectWaitTimes()
{
    for(int onArrayIndex = 0; onArrayIndex < 2; onArrayIndex++)
    {
        while(nNxtButtonPressed != 3)
        {
            if(nNxtButtonPressed == 1)
            {
                waitTimes[onArrayIndex]++;
                nxtDisplayString(onArrayIndex, "Wait %d seconds", waitTimes[onArrayIndex]);
                } else if(nNxtButtonPressed == 2) {
                waitTimes[onArrayIndex]--;
                nxtDisplayString(onArrayIndex, "Wait %d seconds", waitTimes[onArrayIndex]);
            }
            wait1Msec(500);
        }
    }
}
 
task main()
{
    stopTask(displayDiagnostics);
    eraseDisplay();
    initializeRobot();
    //  selectStart();
    selectWaitTimes();
    startTask(displayDiagnostics);
 
    //int target = -13680;
    int target = -8000;
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
 
    //waitForStart();
    /*
    lError = target - nMotorEncoder[liftLeftTop];
    rError = target - nMotorEncoder[liftRightBottom];
 
    lSpeed = BOUND(lError / kp, -100, 100);
    rSpeed = BOUND(rError / kp, -100, 100);
    motor[frontLeft] = lSpeed;
    motor[frontRight] = rSpeed;
    motor[backLeft] = lSpeed;
    motor[backRight] = rSpeed;*/
    if(get90Cm)
    {
        moveStraight(-60 + platformStart);
        } else {
        moveStraight(-54 + platformStart);  //Backwards 54 inches
    }
    motor[frontLeft] = 0;
    motor[frontRight] = 0;
    motor[backLeft] = 0;
    motor[backRight] = 0;
 
    while(servo[latchRight] < 255)
    {
        servo[latchRight] = servo[latchRight] + 10;
        servo[latchLeft] = servo[latchLeft] - 10;
        nxtDisplayString(1, "RServo: %2d", servo[latchRight]);
        nxtDisplayString(2, "LServo: %2d", servo[latchLeft]);
        wait1Msec(25);
    }
    /*
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
    while(nMotorEncoder[liftLeftTop] > -6750 || nMotorEncoder[liftRightBottom] < 6750)
    {
    if(nMotorEncoder[liftLeftTop] != -nMotorEncoder[liftRightBottom])
    {
    error   = nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];
    }
    lError = 6750 - nMotorEncoder[liftLeftTop];
    rError = 6750 - nMotorEncoder[liftRightBottom] + error;
    lSpeed = BOUND(lError / kp, -100, 100);
    rSpeed = BOUND(rError / kp, -100, 100);
 
    motor[frontLeft] = -lSpeed;
    motor[frontRight] = rSpeed;
    motor[backLeft] = -lSpeed;
    motor[backRight] = rSpeed;
    }*/
 
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
    while(nMotorEncoder[liftLeftTop] < 3000)
    {
        lError = 3000 - nMotorEncoder[liftLeftTop];
        rError = 3000 - nMotorEncoder[liftRightBottom];
 
        lSpeed = BOUND(lError / kp, -100, 100);
        rSpeed = BOUND(rError / kp, -20, 20);
        motor[frontLeft] = lSpeed;
        motor[frontRight] = -rSpeed;
        motor[backLeft] = lSpeed;
        motor[backRight] = -rSpeed;
    }
    moveStraight(20);
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
    while(nMotorEncoder[liftRightBottom] < 2000)
    {
        lError = 2000 - nMotorEncoder[liftLeftTop];
        rError = 2000 - nMotorEncoder[liftRightBottom];
 
        lSpeed = BOUND(lError / kp, -20, 20);
        rSpeed = BOUND(rError / kp, -100, 100);
        motor[frontLeft] = -lSpeed;
        motor[frontRight] = rSpeed;
        motor[backLeft] = -lSpeed;
        motor[backRight] = rSpeed;
    }
    moveStraight(55);
    nMotorEncoder[liftLeftTop] = 0;
    nMotorEncoder[liftRightBottom] = 0;
    while(abs(nMotorEncoder[liftLeftTop]) > -4500 && abs(nMotorEncoder[liftRightBottom]) < 4500)
    {
        if(nMotorEncoder[liftLeftTop] != -nMotorEncoder[liftRightBottom])
        {
            error   = nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom];
        }
        lError = 4500 + nMotorEncoder[liftLeftTop];
        rError = 4500 - nMotorEncoder[liftRightBottom] - error;
 
        lSpeed = BOUND(lError / kp, -100, 100);
        rSpeed = BOUND(rError / kp, -100, 100);
        motor[frontLeft] = -lSpeed;
        motor[frontRight] = rSpeed;
        motor[backLeft] = -lSpeed;
        motor[backRight] = rSpeed;
    }
    motor[frontLeft] = 0;
    motor[frontRight] = 0;
    motor[backLeft] = 0;
    motor[backRight] = 0;
    while (true)
    {}
}
