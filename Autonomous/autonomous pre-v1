#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  mtr_S1_C1_1,     frontRight,    tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     backRight,     tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorNormal, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     liftRight,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftLeft,      tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
 
bool startOnPlatform = true;  //True if the robot is starting on the platform. Will be initiated when code is ran
bool startOnBlue = 0;
 
#define BLUE (SensorValue[light] > 30 && SensorValue[light] < 50)
 
unsigned long lastTime;
float input, output, setPoint, error; //PID variables
float iTerm, lastInput; //Integral portion
float kp, ki, kd; //PID constants
float min = 0, max = 100; //Limiting factors
float dInput; //Derivative portion
bool pidOn = false; // True/false for if pid is on. Manual/Auto trigger
int timeChange, sampleTime; // Timing variables
float sampleTimeInSec;
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
 
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
 
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
 
void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
 
  return;
}
 
 
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
 
/*
* Robot goes forward
* @param  speed = speed of movement [default 100]
*         mseconds = (in niliseconds) how long to go forward for [default 1000]
Seconds would be an easier read, but miliseconds are more precise
*/
void forward(int speed = 100, int mseconds = 1000)
{
  motor[frontRight] = speed;
  motor[frontLeft] = speed;
  motor[backRight] = speed;
  motor[backLeft] = speed;
  wait1Msec(mseconds);
}
 
/*
* Robot goes backwards
* @param  speed = speed of movement [default 100]
*         mseconds = (in miliseconds) how long to go backwards for [default 1000]
*/
void backwards(int speed = 100, int mseconds = 1000)
{
  motor[frontRight] = -speed;
  motor[frontLeft] = -speed;
  motor[backRight] = -speed;
  motor[backLeft] = -speed;
  wait1Msec(mseconds);
}
 
/*
* Stops the robot's wheels. "stop" is a reserved keyword... so it's "halt"
*/
void halt()
{
  motor[frontRight] = 0;
  motor[frontLeft] = 0;
  motor[backRight] = 0;
  motor[backLeft] = 0;
}
 
/*
* Robot turns right
* @param  speed = speed of movement [default 100]
*         mseconds = (in miliseconds) how long to go forward for [default 1000]
*/
void turnRight(int speed = 100, int mseconds = 1000)
{
  motor[frontRight] = -speed;
  motor[frontLeft] = speed;
  motor[backRight] = -speed;
  motor[backLeft] = speed;
  wait1Msec(mseconds);
}
 
/*
* Robot turns left
* @param  speed = speed of movement [default 100]
*         mseconds = (in miliseconds) how long to go forward for [default 1000]
*/
void turnLeft(int speed = 100, int mseconds = 1000)
{
  motor[frontRight] = speed;
  motor[frontLeft] = -speed;
  motor[backRight] = speed;
  motor[backLeft] = -speed;
  wait1Msec(mseconds);
}
 
/*
* Robot turns left. Not a pivot
* @param  speed = speed of movement [default 100]
*/
void smoothTurn(int speed = 100)
{
  motor[frontRight] = speed;
  motor[frontLeft] = speed / 2;
  motor[backRight] = speed;
  motor[backLeft] = speed / 2;
}
 
/*
* Move the lift (both up and down)
* @param  speed = speed of movement [default 100]
*         mseconds = (in miliseconds) how long to go for [default 1000]
*/
void moveLift(int speed = 100, int mseconds = 1000)
{
  motor[liftRight] = speed;
  motor[liftLeft] = speed;
  wait1Msec(mseconds);
}
 
/*
* Set which set of movements to use before the game starts
*/
void chooseStartPoint()
{
  StopTask(displayDiagnostics);
  eraseDisplay();
 
  nxtDisplayString(0, "Start Point?");
  while(nNxtButtonPressed != 3)
  {
    if(startOnPlatform)
    {
      nxtDisplayString(1, "Platform");
      } else {
      nxtDisplayString(1, "Parking");
    }
    if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2){
      startOnPlatform = !startOnPlatform; //Right/left?
    }
    wait1Msec(500);
  }
  nxtDisplayString(0, "Color?");
  while(nNxtButtonPressed != 3)
  {
    if(startOnBlue)
    {
      nxtDisplayString(1, "Blue");
      } else {
      nxtDisplayString(1, "Red");
    }
    if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2)
    {
      startOnBlue = !startOnBlue;
    }
    wait1Msec(500);
  }
  //eraseDisplay();
  //StartTask(dispayDiagnostics);
}
 
void setTunings(float Kp, float Ki, float Kd)
{
  if(Kp < 0 || Ki < 0 || Kd < 0) return;
 
  sampleTimeInSec = (sampleTime / 1000);
 
  kp = Kp;
  ki = Ki * sampleTimeInSec;
  kd = Kd / sampleTimeInSec;
}
 
void setSampleTime(int newSampleTime)
{
  if(newSampleTime > 0)
  {
    float ratio = newSampleTime / sampleTime;
    ki *= ratio;
    kd /= ratio;
    sampleTime = (unsigned long) newSampleTime;
  }
}
 
void setLimits(float newMin, float newMax)
{
  if(newMin > newMax) return;
  max = newMax;
  min = newMin;
 
  if(output > max) output = max;
  else if(output < min) output = min;
 
  if(iTerm > max) iTerm = max;
  else if(iTerm < min) iTerm = min;
}
 
void setMode(bool mode)
{
  pidOn = mode;
}
 
void initialize()
{
  lastInput = input;
  iTerm = output;
  if(iTerm > max) iTerm = max;
  else if(iTerm < min) iTerm = min;
}
 
int proportionControl(int leftTarget, int direction) //direction: 0 = straight; 1 = turn left; 2 = turn right
{
  nMotorEncoder[frontLeft] = 0;
  error = (leftTarget - nMotorEncoder[frontLeft]);
int speed = (error * kp) > max ? max : ((error * kp) < min ? min : (error * kp));
  forward(speed, 0);
  while(nMotorRunState[frontLeft] != runStateIdle)
  {
    error = (leftTarget - nMotorEncoder[frontLeft]);
    if(error < 0) error = 0;
    if(error > 0)
    {
    int speed = (error * kp) > max ? max : ((error * kp) < min ? min : (error * kp));
      forward(speed, 0);
      // motor[frontLeft] = motor[frontRight] = motor[backLeft] = motor[backRight] = (error * kp) > max ? max : ((error * kp) < min ? min : (error * kp));
      } else {
      forward(0, 0);
    }
    nxtDisplayString(3, "Speed: %d", speed);
  }
  forward(0, 0);
  return error;
}
 
task updatePID()
{
  while(pidOn)
  {
    long now = nPgmTime;
    timeChange = (now - lastTime);
    if(timeChange >= sampleTime)
    {
      error = setPoint - input;         // Calculate error (desired minus actual)
      iTerm += (ki * error);            // Continue summing the errors in the integral
      if(iTerm > max) iTerm = max;      // Limit the          *
      else if(iTerm < min) iTerm = min; // Integral portion   *
        dInput = (input - lastInput);     // Continue derivative stuff
 
      output = (kp*error) + iTerm + (kd * dInput);
      if(output > max) output = max;
      else if(output < min) output = min;
 
      lastInput = input; // Update these variables  *
      lastTime = now;    // for next time           *
      wait1Msec(1000);
    }
  }
}
 
task main()
{
  initializeRobot();
  chooseStartPoint();
  //waitForStart(); // Wait for the beginning of autonomous phase.
 
  setTunings(2, 1, 1);
  setLimits(-100, 100);    //PID Limits: 0 (minimmum) - 100 (maximum)
  //StartTask(updatePID); Errrrrrr uhhhhhhh
 
  int distanceLeft = proportionControl(5000, 0);
  nxtDisplayString(2, "Distance left: %02x", distanceLeft);
  while(true) {}
  if(startOnPlatform)
  {
    if(startOnBlue)
    {
      while(BLUE)
      {
 
      }
    }
    forward(25, 3000); //Go off ramp
    halt();
    turnLeft(50, 1000); //Turn toward the circular ball-holder
    forward(100, 5000); //Forward to get close to the circular ball-holder
    turnRight(50, 500); //Turn right to prepare to circumnavigate the circular ball-holder to find the irBeacon
    /* while(irBeacon != 5) //*************** get the IRBeacon sensor working
    {
    smoothTurn(25);
    }*/
    turnLeft(50, 500);
    forward(100, 500);
    /*
 
    Score into the 90 goal
 
    */
    } else { //If starting in the parking lot
    forward(100, 5000); //Approach the circular ball-holder
    turnRight(50, 500); //Prepare to circumnavigate the circular ball-holder to find the irBeacon
    /*while(irBeacon != 5) //*************** get the IRBeacon sensor working
    {
    smoothTurn(25);
    }*/
    turnLeft(50, 500);
    forward(100, 500);
    /*
    Score into the 90 goal
    */
  }
 
  while (true)
  {}
}
